#include "wrapper.h"


extern "C" tree_api *create_tree(const tree_options_t &opt) {
    return new lbtree_wrapper(opt);
}

lbtree_wrapper::lbtree_wrapper(const tree_options_t &opt) {
    initUseful(); // as called from main() in lbtree.cc
    worker_id = 0; // the main thread will use worker[0]'s mem/nvm pool
    worker_thread_num = opt.num_threads;

    // assume mempool size is same as nvmpool size, although they can be different
    the_thread_mempools.init(opt.num_threads, opt.pool_size, 4096);
    the_thread_nvmpools.init(opt.num_threads, opt.pool_path.c_str(), opt.pool_size);

    // allocate a 4KB page for the tree in worker 0's pool
    char *nvm_addr= (char *)nvmpool_alloc(4096);
    tree_ = new lbtree(nvm_addr, false);

    bufferedKeyInput *input = new bufferedKeyInput("/mnt/sda4/lbtree/keygen-8B/dbg-k50k", 0, 1);
    tree_->bulkload(1, input, 1.0);
}

lbtree_wrapper::~lbtree_wrapper() {
    delete tree_;
}

bool lbtree_wrapper::find(const char *key, size_t key_sz, char *value_out) {
    // std::cout << "lookup " << key;
    int pos;
    std::string key_str(key);
    long long key_ll = (long long) str_hash(key_str);
    // std::cout << " converted to " << key_ll << std::endl;
    void *p = tree_->lookup(key_ll, &pos);

    // void *recptr = tree_->get_recptr(p, pos);
    // TODO: Populate value_out
    return pos >= 0; // valid position within the leaf node
}

bool lbtree_wrapper::insert(const char *key, size_t key_sz, const char *value, size_t value_sz) {
    // std::cout << "inserting " << key;
    std::string key_str(key);
    long long key_ll = (long long) str_hash(key_str);
    // std::cout << " converted to " << key_ll << std::endl;
    tree_->insert(key_ll, value);
    return true;
    // return find(key, key_sz, NULL);
}

bool lbtree_wrapper::update(const char *key, size_t key_sz, const char *value, size_t value_sz) {
    // There is not explciit update method in lbtree
    // Redirect to insert
    return insert(key, key_sz, value, value_sz);
}

int lbtree_wrapper::scan(const char *key, size_t key_sz, int scan_sz, char *&values_out) {
    // Operation not implemented in lbtree
    return -1;
}

bool lbtree_wrapper::remove(const char *key, size_t key_sz) {
    // key generated by pibench is already an integer, so we can convert it to long long
    while (*key < '0' || *key > '9') key++;
    tree_->del(atoll(key));
    // TODO: Can check if the value is deleted, but that might require extra 'lookup' call
    return true;
}
